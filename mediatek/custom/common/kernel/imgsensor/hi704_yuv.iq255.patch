diff -rubN hi704_yuv/hi704yuv_CameraCustomized.h hi704_yuv.iq255/hi704yuv_CameraCustomized.h
--- hi704_yuv/hi704yuv_CameraCustomized.h	2012-11-13 05:55:02.000000000 +0200
+++ hi704_yuv.iq255/hi704yuv_CameraCustomized.h	2012-05-02 21:05:52.000000000 +0300
@@ -1,4 +1,111 @@
-
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *   PC Huang (MTK02204)
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * 07 11 2011 jun.pei
+ * [ALPS00059464] hi704 sensor check in
+ * .
+ *
+ * .
+ * Add HI704 YUV sensor driver support
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
 
 #ifndef __CAMERA_CUSTOMIZED_H
 #define __CAMERA_CUSTOMIZED_H
@@ -20,6 +127,18 @@
 #define CAM_SIZE_QVGA_HEIGHT 	240
 #define CAM_SIZE_VGA_WIDTH 		640
 #define CAM_SIZE_VGA_HEIGHT 	480
+/*
+#define CAM_SIZE_05M_WIDTH 		800
+#define CAM_SIZE_05M_HEIGHT 	600
+#define CAM_SIZE_1M_WIDTH 		1280
+#define CAM_SIZE_1M_HEIGHT 		960
+#define CAM_SIZE_2M_WIDTH 		1600
+#define CAM_SIZE_2M_HEIGHT 		1200
+#define CAM_SIZE_3M_WIDTH 		2048
+#define CAM_SIZE_3M_HEIGHT 		1536
+#define CAM_SIZE_5M_WIDTH 		2592
+#define CAM_SIZE_5M_HEIGHT 		1944
+*/
 // for main sensor
 #define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
 #define MAIN_NUM_OF_VIDEO_RESOLUTION 3
diff -rubN hi704_yuv/hi704yuv_Camera_Sensor_para.h hi704_yuv.iq255/hi704yuv_Camera_Sensor_para.h
--- hi704_yuv/hi704yuv_Camera_Sensor_para.h	2012-11-13 05:55:51.000000000 +0200
+++ hi704_yuv.iq255/hi704yuv_Camera_Sensor_para.h	2012-05-02 21:05:52.000000000 +0300
@@ -1,4 +1,127 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
 
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * 07 11 2011 jun.pei
+ * [ALPS00059464] hi704 sensor check in
+ * .
+ *
+ * 05 25 2010 sean.cheng
+ * [ALPS00001357][Meta]CameraTool 
+ * .
+ * Add HI704 YUV sensor driver support
+ *
+ * Mar 4 2010 mtk70508
+ * [DUMA00154792] Sensor driver
+ * 
+ *
+ * Feb 24 2010 mtk01118
+ * [DUMA00025869] [Camera][YUV I/F & Query feature] check in camera code
+ * 
+ *
+ * Apr 7 2009 mtk02204
+ * [DUMA00004012] [Camera] Restructure and rename camera related custom folders and folder name of came
+ * 
+ *
+ * Feb 24 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ * 
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
 /* SENSOR FULL SIZE */
 #ifndef __CAMERA_SENSOR_PARA_H
 #define __CAMERA_SENSOR_PARA_H
diff -rubN hi704_yuv/hi704yuv_Sensor.c hi704_yuv.iq255/hi704yuv_Sensor.c
--- hi704_yuv/hi704yuv_Sensor.c	2012-11-13 05:56:32.000000000 +0200
+++ hi704_yuv.iq255/hi704yuv_Sensor.c	2012-08-02 18:00:24.000000000 +0300
@@ -1,4 +1,104 @@
-
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.c
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Source code of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   PC Huang (MTK02204)
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
 #include <linux/videodev2.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
@@ -58,19 +158,47 @@
     return get_byte;
 }
 
+void HI704_Write_Shutter(kal_uint32 shutter)
+{
+    HI704_write_cmos_sensor(0x03, 0x20);
+    HI704_write_cmos_sensor(0x83, shutter >> 16);
+    HI704_write_cmos_sensor(0x84, (shutter >> 8) & 0x000000FF);
+    HI704_write_cmos_sensor(0x85, shutter & 0x000000FF);
+}
+
+kal_uint32 HI704_Read_Shutter(void)
+	{
+	kal_uint32 iExp;
+
+	HI704_write_cmos_sensor(0x03, 0x20);
+	iExp= (HI704_read_cmos_sensor(0x80) << 16) |
+		(HI704_read_cmos_sensor(0x81) << 8)  |
+		HI704_read_cmos_sensor(0x82);
 
+	// kal_prompt_trace(MOD_ENG,"Shutter=%x",iExp);
+	return iExp;
+}
+
+/*******************************************************************************
+* // Adapter for Winmo typedef 
+********************************************************************************/
 #define WINMO_USE 0
 
 #define Sleep(ms) mdelay(ms)
 #define RETAILMSG(x,...)
 #define TEXT
+kal_uint8 HI704_Sleep_Mode;
 
-
+/*******************************************************************************
+* follow is define by jun
+********************************************************************************/
 MSDK_SENSOR_CONFIG_STRUCT HI704SensorConfigData;
 
 static struct HI704_sensor_STRUCT HI704_sensor;
 static kal_uint32 HI704_zoom_factor = 0; 
 static int sensor_id_fail = 0;	
+static kal_uint32 HI704_pv_exposure_lines=0;
+static kal_bool HI704_VIDEO_ENABLE = KAL_FALSE;
 const HI704_SENSOR_INIT_INFO HI704_Initial_Setting_Info[] =
 {
   
@@ -100,7 +228,7 @@
     {0x43, 0x13},   //0x04 -> 0x40: For Max Framerate = 30fps
             
     //BLC
-    {0x80, 0x2e},//0X2e,0314
+	{0x80, 0x2e},
     {0x81, 0x7e},
     {0x82, 0x90},
     {0x83, 0x30},
@@ -108,10 +236,10 @@
     {0x85, 0x4b},
     {0x89, 0x48},
         
-    {0x90, 0x0a},
-    {0x91, 0x0a},    
+	{0x90, 0x0b},
+	{0x91, 0x0b},    
     {0x92, 0x48},
-    {0x93, 0x40},
+	{0x93, 0x48},
     {0x98, 0x38},
     {0x99, 0x40},
     {0xa0, 0x00},
@@ -200,17 +328,17 @@
         
     {0x40, 0x80},
     {0x41, 0x02},
-    {0x48, 0x98},
+	{0x48, 0x98},  //0x90 mingji 0210
         
     {0x50, 0x48},
            
     {0x60, 0x7f},
     {0x61, 0x00},
-    {0x62, 0xb0},
-    {0x63, 0xa8},
+	{0x62, 0x90},
+	{0x63, 0xa0},
     {0x64, 0x48},
     {0x66, 0x90},
-    {0x67, 0x42},
+	{0x67, 0x67},
     
     //PAGE 11
     //Z-LPF
@@ -223,7 +351,7 @@
     {0x23, 0x0a},
         
     {0x60, 0x10},   
-    {0x61, 0x82},
+	{0x61, 0xc2},//0x82
     {0x62, 0x00},   
     {0x63, 0x83},   
     {0x64, 0x83},      
@@ -235,11 +363,11 @@
     //2D
     {0x03, 0x12},
         
-    {0x40, 0xe9},
+	{0x40, 0xeb},//0xe9,
     {0x41, 0x09},
         
     {0x50, 0x18},
-    {0x51, 0x24},
+	{0x51, 0x28},//0x24
         
     {0x70, 0x1f},
     {0x71, 0x00},
@@ -311,15 +439,15 @@
     {0x16, 0x2c},
     {0x17, 0x2f},
           
-    {0x30, 0xc4},
-    {0x31, 0x5b},
-    {0x32, 0x1f},
-    {0x33, 0x2a},
+	{0x30, 0xcb},
+	{0x31, 0x61},
+	{0x32, 0x16},
+	{0x33, 0x23},
     {0x34, 0xce},
-    {0x35, 0x24},
-    {0x36, 0x0b},
-    {0x37, 0x3f},
-    {0x38, 0x8a},
+	{0x35, 0x2b},
+	{0x36, 0x01},
+	{0x37, 0x34},
+	{0x38, 0x75},
            
     {0x40, 0x87},
     {0x41, 0x18},
@@ -336,19 +464,19 @@
     {0x03,  0x16},
         
     {0x30,  0x00},
-    {0x31,  0x1c},
-    {0x32,  0x2d},
-    {0x33,  0x4e},
-    {0x34,  0x6d},
-    {0x35,  0x8b},
-    {0x36,  0xa2},
-    {0x37,  0xb5},
-    {0x38,  0xc4},
-    {0x39,  0xd0},
-    {0x3a,  0xda},
-    {0x3b,  0xea},
-    {0x3c,  0xf4},
-    {0x3d,  0xfb},
+	{0x31,  0x0a},
+	{0x32,  0x1b},
+	{0x33,  0x2e},
+	{0x34,  0x5c},
+	{0x35,  0x79},
+	{0x36,  0x95},
+	{0x37,  0xa4},
+	{0x38,  0xb1},
+	{0x39,  0xbd},
+	{0x3a,  0xc8},
+	{0x3b,  0xd9},
+	{0x3c,  0xe8},
+	{0x3d,  0xf5},
     {0x3e,  0xff},
     
     //PAGE 17 
@@ -378,13 +506,13 @@
     {0x3b, 0x22},
     {0x3c, 0xde},
     
-    {0x60, 0x95},
+	{0x60, 0xc0},//0x95
     {0x68, 0x3c},
     {0x69, 0x64},
     {0x6A, 0x28},
     {0x6B, 0xc8},
     
-    {0x70, 0x42},   //For Y decay   
+	{0x70, 0x48},   //For Y decay   
     {0x76, 0x22},
     {0x77, 0x02},   
     {0x78, 0x12},
@@ -401,8 +529,8 @@
     {0x87, 0xfa},
         
     {0x88, 0x02},
-    {0x89, 0x7a},
-    {0x8a, 0xc4},    
+	{0x89, 0xf9},
+	{0x8a, 0xb8},
         
     {0x8b, 0x3f},
     {0x8c, 0x7a},  
@@ -419,8 +547,8 @@
     {0x98, 0x8C},
     {0x99, 0x23},  
         
-    {0x9c, 0x0b},   //For Y decay: Exposure Time
-    {0x9d, 0xb8},   //For Y decay: Exposure Time
+	{0x9c, 0x06},   //For Y decay: Exposure Time
+	{0x9d, 0xd6},   //For Y decay: Exposure Time
     {0x9e, 0x00},
     {0x9f, 0xfa},
     
@@ -449,14 +577,14 @@
         
     {0x21, 0x40},
            
-    {0x30, 0x80},
-    {0x31, 0x80},
+	{0x30, 0x80},//ULVL U,V awb converge targe //0x80 mingji modified 0208 //0x7e 0209
+	{0x31, 0x80},//VLVL //0x80 mingji modified 0208 0x81 0209
     {0x38, 0x12},
     {0x39, 0x33},
         
     {0x40, 0xf0},
-    {0x41, 0x33},
-    {0x42, 0x33},
+	{0x41, 0x32},//0x33  converge range //0x32 mingji modified 0208 //0x31 mingji 0209
+	{0x42, 0x32},//0x33  //0x31 mingji 0210
     {0x43, 0xf3},
     {0x44, 0x55},
     {0x45, 0x44},
@@ -467,7 +595,7 @@
     {0x82, 0x48},
     {0x83, 0x52},
     {0x84, 0x1b},
-    {0x85, 0x50},
+	{0x85, 0x44},
     {0x86, 0x25},
     {0x87, 0x4d},
     {0x88, 0x38},
@@ -501,15 +629,14 @@
     
     {0x01, 0xf0},
 
-    //PAGE 0
-    {0x03, 0x00},
-    {0x01, 0x90},   //0xf1 ->0x41 : For Preview Green/Red Line.
+	//{0x01, 0x90},   //0xf1 ->0x41 : For Preview Green/Red Line.
 
 	{0xff, 0xff}    //End of Initial Setting
 
 };
 static void HI704_Initial_Setting(void)
 {
+
 	kal_uint32 iEcount;
 	for(iEcount=0;(!((0xff==(HI704_Initial_Setting_Info[iEcount].address))&&(0xff==(HI704_Initial_Setting_Info[iEcount].data))));iEcount++)
 	{	
@@ -545,6 +672,7 @@
 
 static kal_uint8 HI704_power_on(void)
 {
+
     kal_uint8 HI704_sensor_id = 0;
 
 	HI704_sensor.pv_pclk = 13000000;
@@ -557,13 +685,34 @@
 	HI704_sensor_id = HI704_read_cmos_sensor(0x04);
     SENSORDB("[HI704YUV]:read Sensor ID:%x\n",HI704_sensor_id);
 	
+	HI704_write_cmos_sensor(0x03, 0x20);
+	HI704_pv_exposure_lines  = (HI704_read_cmos_sensor(0x83) << 16) |
+					(HI704_read_cmos_sensor(0x84) << 8)  |
+					HI704_read_cmos_sensor(0x85);
+	printk("MINGJI HI704_power_on HI704_pv_exposure_lines=%d\n",HI704_pv_exposure_lines);
 	return HI704_sensor_id;
 }
 
 
+/*************************************************************************
+* FUNCTION
+*	HI704Open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 UINT32 HI704Open(void)
 {
-   
+	SENSORDB("MINGJI Test HI704Open() calling!");
        sensor_id_fail = 0; 
 	   
        SENSORDB("[Enter]:HI704 Open func:");
@@ -575,7 +724,6 @@
 		   return ERROR_SENSOR_CONNECT_FAIL;
 	 	}
     
-      
     /* Apply sensor initail setting*/
      HI704_Initial_Setting();
 	 HI704_Init_Parameter(); 
@@ -585,6 +733,22 @@
 	return ERROR_NONE;
 }	/* HI704Open() */
 
+/*************************************************************************
+* FUNCTION
+*	HI704_GetSensorID
+*
+* DESCRIPTION
+*	This function get the sensor ID
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 static kal_uint32 HI704_GetSensorID(kal_uint32 *sensorID)
 
 {
@@ -593,27 +757,41 @@
 
      if (*sensorID != HI704_SENSOR_ID) 
  	{
- 	   
 	  SENSORDB("[HI704]Error:read sensor ID fail\n");
 	  sensor_id_fail = 1;
-	  *sensorID = 0xFFFFFFFF; 
+		*sensorID =0xffffffff; 
 	  return ERROR_SENSOR_CONNECT_FAIL;
    }
 	   
-
     return ERROR_NONE;    
 }   /* HI704Open  */
 
 
+/*************************************************************************
+* FUNCTION
+*	HI704Close
+*
+* DESCRIPTION
+*	This function is to turn off sensor module power.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 UINT32 HI704Close(void)
 {
-
 	return ERROR_NONE;
 }	/* HI704Close() */
 
 
 static void HI704_Set_Mirror_Flip(kal_uint8 image_mirror)
 {
+
   /********************************************************
     * Page Mode 0: Reg 0x0011 bit[1:0] = [Y Flip : X Flip]
     * 0: Off; 1: On.
@@ -643,12 +821,13 @@
 
     HI704_write_cmos_sensor(0x11, HI704_sensor.mirror);
 
-	SENSORDB("[Exit]:HI704 set Mirror_flip func\n");
+	SENSORDB("[Exit]:HI704 set Mirror_flip func mirror=%d\n",HI704_sensor.mirror);
 
 }
 
 static void HI704_set_dummy(kal_uint16 dummy_pixels,kal_uint16 dummy_lines)
 {	
+
 	HI704_write_cmos_sensor(0x03, 0x00);                        //Page 0
 	HI704_write_cmos_sensor(0x40,((dummy_pixels & 0x0F00))>>8);       //HBLANK
 	HI704_write_cmos_sensor(0x41,(dummy_pixels & 0xFF));
@@ -660,6 +839,7 @@
 // 640 * 480
 static void HI704_Set_VGA_mode(void)
 {
+
     HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)|0x01);   //Sleep: For Write Reg
 
     HI704_write_cmos_sensor(0x03, 0x00);
@@ -671,7 +851,7 @@
     HI704_write_cmos_sensor(0x40, 0x01);        //HBLANK: 0x70 = 112
     HI704_write_cmos_sensor(0x41, 0x58);
     HI704_write_cmos_sensor(0x42, 0x00);        //VBLANK: 0x04 = 4
-    HI704_write_cmos_sensor(0x43, 0x13);
+	HI704_write_cmos_sensor(0x43, 0x14);
 
     HI704_write_cmos_sensor(0x03, 0x11);
     HI704_write_cmos_sensor(0x10, 0x25);  
@@ -681,9 +861,11 @@
     HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)&0x7f);   //Close AE
     HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)|0x08);   //Reset AE
 	
-    HI704_write_cmos_sensor(0x83, 0x00);
-    HI704_write_cmos_sensor(0x84, 0xbe);
-    HI704_write_cmos_sensor(0x85, 0x6e);
+
+	HI704_write_cmos_sensor(0x83, HI704_pv_exposure_lines >> 16);
+	HI704_write_cmos_sensor(0x84, (HI704_pv_exposure_lines >> 8) & 0x000000FF);
+	HI704_write_cmos_sensor(0x85, HI704_pv_exposure_lines & 0x000000FF);
+
     HI704_write_cmos_sensor(0x86, 0x00);
     HI704_write_cmos_sensor(0x87, 0xfa);
 
@@ -692,8 +874,8 @@
     HI704_write_cmos_sensor(0x8d, 0x34);
     HI704_write_cmos_sensor(0x8e, 0xbc);
 
-    HI704_write_cmos_sensor(0x9c, 0x0b);
-    HI704_write_cmos_sensor(0x9d, 0xb8);
+	HI704_write_cmos_sensor(0x9c, 0x06);
+	HI704_write_cmos_sensor(0x9d, 0xd6);
     HI704_write_cmos_sensor(0x9e, 0x00);
     HI704_write_cmos_sensor(0x9f, 0xfa);
 
@@ -702,220 +884,228 @@
     HI704_write_cmos_sensor(0x03, 0x20);
     HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)|0x80);   //Open AE
     HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)&0xf7);   //Reset AE
-
+	printk("MINGJI HI704_Set_VGA_mode HI704_pv_exposure_lines=%d\n",HI704_pv_exposure_lines);
+	//mdelay(20);
 }
-
-static void HI704_Cal_Min_Frame_Rate(kal_uint16 min_framerate)
+void HI704_night_mode(kal_bool enable)
 {
-    kal_uint32 HI704_expmax;
-    kal_uint32 HI704_expbanding;
-
+	SENSORDB("MINGJI Test HI704_night_mode() calling!");
+	SENSORDB("[Enter]HI704 night mode func:enable = %d\n",enable);
+	SENSORDB("HI704_sensor.video_mode = %d\n",HI704_sensor.MPEG4_Video_mode); 
+	SENSORDB("HI704_sensor.night_mode = %d\n",HI704_sensor.night_mode);
   
-    SENSORDB("[HI704] HI704_Cal_Min_Frame_Rate:min_fps=%d\n",min_framerate);
+	HI704_sensor.night_mode = enable;
 
-    //No Fixed Framerate
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)|0x01);   //Sleep: For Write Reg
+	if(enable)
+	{
+		if(HI704_sensor.MPEG4_Video_mode == KAL_TRUE)
+		{
+			//HI704_Fix_Video_Frame_Rate(HI704_MIN_FRAMERATE_7_5);
+	        HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x01;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
 
-    HI704_write_cmos_sensor(0x03, 0x00);
-    HI704_write_cmos_sensor(0x11, HI704_read_cmos_sensor(0x11)&0xfb);
+			//HI704_write_cmos_sensor(0x11, 0x90);
     
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)&0x7f);   //Close AE
+			HI704_write_cmos_sensor(0x10, 0x1c);
     
-    HI704_write_cmos_sensor(0x11, 0x04);
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)|0x08);   //Reset AE
-    HI704_write_cmos_sensor(0x2a, 0xf0);
-    HI704_write_cmos_sensor(0x2b, 0x34);
-
-    HI704_write_cmos_sensor(0x03, 0x00);
-    HI704_sensor.pv_dummy_pixels = ((HI704_read_cmos_sensor(0x40)<<8)|HI704_read_cmos_sensor(0x41));
-    HI704_sensor.pv_line_length = HI704_VGA_DEFAULT_PIXEL_NUMS+ HI704_sensor.pv_dummy_pixels ;
+			HI704_write_cmos_sensor(0x03, 0x20);
+			HI704_write_cmos_sensor(0x18, 0x38);
 
     if(HI704_sensor.banding == AE_FLICKER_MODE_50HZ)
     {
-        HI704_expbanding = (HI704_sensor.pv_pclk/HI704_sensor.pv_line_length/100)*HI704_sensor.pv_line_length/8;
-        HI704_expmax = HI704_expbanding*100*10/min_framerate ;
-    }
-    else if(HI704_sensor.banding == AE_FLICKER_MODE_60HZ)
-    {
-        HI704_expbanding = (HI704_sensor.pv_pclk/HI704_sensor.pv_line_length/120)*HI704_sensor.pv_line_length/8;
-        HI704_expmax = HI704_expbanding*120*10/min_framerate ;
+				HI704_write_cmos_sensor(0x83, 0x00);
+				HI704_write_cmos_sensor(0x84, 0xbe);
+				HI704_write_cmos_sensor(0x85, 0x6e);
     }
     else
     {
-        SENSORDB("[HI704][Error] Wrong Banding Setting!!!...");
+				HI704_write_cmos_sensor(0x83,0x00);
+				HI704_write_cmos_sensor(0x84,0xd2);
+				HI704_write_cmos_sensor(0x85,0xf0);
     }
     
-    HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x88, (HI704_expmax>>16)&0xff);
-    HI704_write_cmos_sensor(0x89, (HI704_expmax>>8)&0xff);
-    HI704_write_cmos_sensor(0x8a, (HI704_expmax>>0)&0xff);
-
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)&0xfe);   //Exit Sleep: For Write Reg
+			HI704_write_cmos_sensor(0x88, 0x04);
+			HI704_write_cmos_sensor(0x89, 0xf5);
+			HI704_write_cmos_sensor(0x8a, 0x88);
+				
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x00;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)|0x80);   //Open AE
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)&0xf7);   //Reset AE
-}
-
-
-static void HI704_Fix_Video_Frame_Rate(kal_uint16 fix_framerate)
-{
-    kal_uint32 HI704_expfix;
-    kal_uint32 HI704_expfix_temp;
-    kal_uint32 HI704_expmax;
-    kal_uint32 HI704_expbanding;
+			HI704_write_cmos_sensor(0x10, 0x9c);
     
+			HI704_write_cmos_sensor(0x18, 0x30);
+		}
+		else
+		{
+			 //HI704_Cal_Min_Frame_Rate(HI704_MIN_FRAMERATE_5);        
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x01;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
   
-    SENSORDB("[Enter]HI704 Fix_video_frame_rate func: fix_fps=%d\n",fix_framerate);
-
-
-	HI704_sensor.video_current_frame_rate = fix_framerate;
-    // Fixed Framerate
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)|0x01);   //Sleep: For Write Reg
-
-    HI704_write_cmos_sensor(0x03, 0x00);
-    HI704_write_cmos_sensor(0x11, HI704_read_cmos_sensor(0x11)|0x04);
+			//HI704_write_cmos_sensor(0x11, 0x90);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)&0x7f);   //Close AE
-    
-    HI704_write_cmos_sensor(0x11, 0x00);
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)|0x08);   //Reset AE
-    HI704_write_cmos_sensor(0x2a, 0x00);
-    HI704_write_cmos_sensor(0x2b, 0x35);
+			HI704_write_cmos_sensor(0x10, 0x1c);
 
-    HI704_write_cmos_sensor(0x03, 0x00);
-    HI704_sensor.pv_dummy_pixels = ((HI704_read_cmos_sensor(0x40)<<8)|HI704_read_cmos_sensor(0x41));
-    
-
-    HI704_sensor.pv_line_length = HI704_VGA_DEFAULT_PIXEL_NUMS + HI704_sensor.pv_dummy_pixels ;
+			HI704_write_cmos_sensor(0x03, 0x20);
+			HI704_write_cmos_sensor(0x18, 0x38);
     
+			if(HI704_sensor.banding == AE_FLICKER_MODE_50HZ)
+			{
+				HI704_write_cmos_sensor(0x83, 0x00);
+				HI704_write_cmos_sensor(0x84, 0xbe);
+				HI704_write_cmos_sensor(0x85, 0x6e);
+			}
+			else
+			{
+				HI704_write_cmos_sensor(0x83,0x00);
+				HI704_write_cmos_sensor(0x84,0xd2);
+				HI704_write_cmos_sensor(0x85,0xf0);
+			}
     
-    HI704_sensor.pv_dummy_lines = ((HI704_read_cmos_sensor(0x42)<<8)|HI704_read_cmos_sensor(0x43));
+			HI704_write_cmos_sensor(0x88, 0x04);
+			HI704_write_cmos_sensor(0x89, 0xf5);
+			HI704_write_cmos_sensor(0x8a, 0x88);
+				
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x00;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
     
+			HI704_write_cmos_sensor(0x03, 0x20);
+			HI704_write_cmos_sensor(0x10, 0x9c);
     
-    HI704_expfix_temp = ((HI704_sensor.pv_pclk*10/fix_framerate)-(HI704_sensor.pv_line_length*HI704_sensor.pv_dummy_lines))/8;
+			HI704_write_cmos_sensor(0x18, 0x30);
+		}
+	}
+	else
+	{
+		if(HI704_sensor.MPEG4_Video_mode == KAL_TRUE)
+	    	{
+			//HI704_Fix_Video_Frame_Rate(HI704_MIN_FRAMERATE_10);
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x01;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
     
-    HI704_expfix = ((HI704_expfix_temp*8/HI704_sensor.pv_line_length)*HI704_sensor.pv_line_length)/8;
+			//HI704_write_cmos_sensor(0x11, 0x90);
     
+			HI704_write_cmos_sensor(0x03, 0x20);
+			HI704_write_cmos_sensor(0x10, 0x1c);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    //HI704_write_cmos_sensor(0x83, (HI704_expfix>>16)&0xff);
-    //HI704_write_cmos_sensor(0x84, (HI704_expfix>>8)&0xff);
-    //HI704_write_cmos_sensor(0x85, (HI704_expfix>>0)&0xff);
-    HI704_write_cmos_sensor(0x91, (HI704_expfix>>16)&0xff);
-    HI704_write_cmos_sensor(0x92, (HI704_expfix>>8)&0xff);
-    HI704_write_cmos_sensor(0x93, (HI704_expfix>>0)&0xff);
+			HI704_write_cmos_sensor(0x18, 0x38);
 
     if(HI704_sensor.banding == AE_FLICKER_MODE_50HZ)
     {
-        HI704_expbanding = ((HI704_read_cmos_sensor(0x8b)<<8)|HI704_read_cmos_sensor(0x8c));
-    }
-    else if(HI704_sensor.banding == AE_FLICKER_MODE_60HZ)
-    {
-        HI704_expbanding = ((HI704_read_cmos_sensor(0x8d)<<8)|HI704_read_cmos_sensor(0x8e));
+				HI704_write_cmos_sensor(0x83, 0x00);
+				HI704_write_cmos_sensor(0x84, 0xbe);
+				HI704_write_cmos_sensor(0x85, 0x6e);
     }
     else
     {
-        SENSORDB("[HI704]Wrong Banding Setting!!!...");
+				HI704_write_cmos_sensor(0x83,0x00);
+				HI704_write_cmos_sensor(0x84,0xd2);
+				HI704_write_cmos_sensor(0x85,0xf0);
     }
-    HI704_expmax = ((HI704_expfix_temp-HI704_expbanding)/HI704_expbanding)*HI704_expbanding;
-
-    
     
-    HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x88, (HI704_expmax>>16)&0xff);
-    HI704_write_cmos_sensor(0x89, (HI704_expmax>>8)&0xff);
-    HI704_write_cmos_sensor(0x8a, (HI704_expmax>>0)&0xff);
-
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)&0xfe);   //Exit Sleep: For Write Reg
+			HI704_write_cmos_sensor(0x88, 0x02);
+			HI704_write_cmos_sensor(0x89, 0x7a);
+			HI704_write_cmos_sensor(0x8a, 0xc4);
+				
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x00;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)|0x80);   //Open AE
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)&0xf7);   //Reset AE
-
-}
+			HI704_write_cmos_sensor(0x10, 0x9c);
 
+			HI704_write_cmos_sensor(0x18, 0x30);
+	    	}
 
-// 320 * 240
-static void HI704_Set_QVGA_mode(void)
-{
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)|0x01);   //Sleep: For Write Reg
-    
-    HI704_write_cmos_sensor(0x03, 0x00);
-    HI704_write_cmos_sensor(0x10, 0x01);        //QVGA Size: 0x10 -> 0x01
-
-    HI704_write_cmos_sensor(0x20, 0x00);
-    HI704_write_cmos_sensor(0x21, 0x02);
+		else
+		{
+			//HI704_Cal_Min_Frame_Rate(HI704_MIN_FRAMERATE_10);      
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x01;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
 
-    HI704_write_cmos_sensor(0x40, 0x01);        //HBLANK:  0x0158 = 344
-    HI704_write_cmos_sensor(0x41, 0x58);
-    HI704_write_cmos_sensor(0x42, 0x00);        //VBLANK:  0x14 = 20
-    HI704_write_cmos_sensor(0x43, 0x14);
+			//HI704_write_cmos_sensor(0x11, 0x90);
 
-    HI704_write_cmos_sensor(0x03, 0x11);        //QVGA Fixframerate
-    HI704_write_cmos_sensor(0x10, 0x21);  
+			HI704_write_cmos_sensor(0x03, 0x20);
+			HI704_write_cmos_sensor(0x10, 0x1c);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)&0x7f);   //Close AE
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)|0x08);   //Reset AE
+			HI704_write_cmos_sensor(0x18, 0x38);
 
+			if(HI704_sensor.banding == AE_FLICKER_MODE_50HZ)
+			{
     HI704_write_cmos_sensor(0x83, 0x00);
-    HI704_write_cmos_sensor(0x84, 0xaf);
-    HI704_write_cmos_sensor(0x85, 0xc8);
-    HI704_write_cmos_sensor(0x86, 0x00);
-    HI704_write_cmos_sensor(0x87, 0xfa);
-
-    HI704_write_cmos_sensor(0x8b, 0x3a);
-    HI704_write_cmos_sensor(0x8c, 0x98);
-    HI704_write_cmos_sensor(0x8d, 0x30);
-    HI704_write_cmos_sensor(0x8e, 0xd4);
-
-    HI704_write_cmos_sensor(0x9c, 0x0b);
-    HI704_write_cmos_sensor(0x9d, 0x3b);
-    HI704_write_cmos_sensor(0x9e, 0x00);
-    HI704_write_cmos_sensor(0x9f, 0xfa);
+				HI704_write_cmos_sensor(0x84, 0xbe);
+				HI704_write_cmos_sensor(0x85, 0x6e);
+			}
+			else
+			{
+				HI704_write_cmos_sensor(0x83,0x00);
+				HI704_write_cmos_sensor(0x84,0xd2);
+				HI704_write_cmos_sensor(0x85,0xf0);
+			}
 
-    HI704_write_cmos_sensor(0x01, HI704_read_cmos_sensor(0x01)&0xfe);   //Exit Sleep: For Write Reg
+			HI704_write_cmos_sensor(0x88, 0x02);
+			HI704_write_cmos_sensor(0x89, 0x7a);
+			HI704_write_cmos_sensor(0x8a, 0xc4);
+				
+			HI704_write_cmos_sensor(0x03,0x00); 	
+			HI704_Sleep_Mode = (HI704_read_cmos_sensor(0x01) & 0xfe);
+			HI704_Sleep_Mode |= 0x00;
+			HI704_write_cmos_sensor(0x01, HI704_Sleep_Mode);
 
     HI704_write_cmos_sensor(0x03, 0x20);
-    HI704_write_cmos_sensor(0x10, HI704_read_cmos_sensor(0x10)|0x80);   //Open AE
-    HI704_write_cmos_sensor(0x18, HI704_read_cmos_sensor(0x18)&0xf7);   //Reset AE
-
-}
-void HI704_night_mode(kal_bool enable)
-{
-
-	  SENSORDB("[Enter]HI704 night mode func:enable = %d\n",enable);
-	  SENSORDB("HI704_sensor.video_mode = %d\n",HI704_sensor.MPEG4_Video_mode); 
-      SENSORDB("HI704_sensor.night_mode = %d\n",HI704_sensor.night_mode);
-
-	HI704_sensor.night_mode = enable;
-
-    if(HI704_sensor.MPEG4_Video_mode == KAL_TRUE)
-	    return;
+			HI704_write_cmos_sensor(0x10, 0x9c);
 
-	if(enable)
-	{
-        HI704_Cal_Min_Frame_Rate(HI704_MIN_FRAMERATE_5);                            
+			HI704_write_cmos_sensor(0x18, 0x30);
 	}
-	else
-    {
-	    HI704_Cal_Min_Frame_Rate(HI704_MIN_FRAMERATE_10);
 	}
+	//HI704_Set_Mirror_Flip(IMAGE_HV_MIRROR);//IMAGE_HV_MIRROR //IMAGE_NORMAL
 }
 
+/*************************************************************************
+* FUNCTION
+*	HI704Preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 static UINT32 HI704Preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-	
+	SENSORDB("MINGJI Test HI704Preview() calling!");
 	if(HI704_sensor.first_init == KAL_TRUE)
 		HI704_sensor.MPEG4_Video_mode = HI704_sensor.MPEG4_Video_mode;
-	else
+	else if(HI704_VIDEO_ENABLE)
+		{
 		HI704_sensor.MPEG4_Video_mode = !HI704_sensor.MPEG4_Video_mode;
-
-	
+			HI704_VIDEO_ENABLE = KAL_FALSE;
+		}
 	SENSORDB("[Enter]:HI704 preview func:");		
 	SENSORDB("HI704_sensor.video_mode = %d\n",HI704_sensor.MPEG4_Video_mode); 
 
@@ -926,22 +1116,56 @@
 	    SENSORDB("[HI704]preview set_VGA_mode\n");
 		HI704_Set_VGA_mode();
    	}
-   
-	HI704_Set_Mirror_Flip(sensor_config_data->SensorImageMirror);
+      // HI704_Set_Mirror_Flip(sensor_config_data->SensorImageMirror);//wmhai add it
+	HI704_Set_Mirror_Flip(IMAGE_HV_MIRROR);
+       SENSORDB("[HI704][Enter]HI704_capture_func sensor_config_data->SensorImageMirror %d\n",sensor_config_data->SensorImageMirror);
+	printk("MINGJI HI704Preview HI704_pv_exposure_lines=%d\n",HI704_pv_exposure_lines);
 
 	SENSORDB("[Exit]:HI704 preview func\n");
     return TRUE; 
 }	/* HI704_Preview */
 
-
 UINT32 HI704Capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {	
-
+	SENSORDB("MINGJI Test HI704Capture() calling!");
 	SENSORDB("[HI704][Enter]HI704_capture_func\n");
 	
 	HI704_sensor.pv_mode = KAL_FALSE;	
+	HI704_pv_exposure_lines=HI704_Read_Shutter();//162500;
+	//HI704_pv_exposure_lines = HI704_pv_exposure_lines/2;
+	printk("MINGJI HI704Capture HI704_pv_exposure_lines=%d\n",HI704_pv_exposure_lines);
+	//HI704_Set_VGA_mode();
+
+
+	HI704_write_cmos_sensor(0x03, 0x00);
+	HI704_write_cmos_sensor(0x10, 0x00);        //VGA Size
+	HI704_write_cmos_sensor(0x12, 0x04);
+
+	HI704_write_cmos_sensor(0x20, 0x00);
+	HI704_write_cmos_sensor(0x21, 0x04);
+	HI704_write_cmos_sensor(0x22, 0x00);
+	HI704_write_cmos_sensor(0x23, 0x04);
+
+	HI704_write_cmos_sensor(0x40, 0x00);        //HBLANK: 0x70 = 112
+	HI704_write_cmos_sensor(0x41, 0x70);
+	HI704_write_cmos_sensor(0x42, 0x00);        //VBLANK: 0x04 = 4
+	HI704_write_cmos_sensor(0x43, 0x04);
 		
+	HI704_write_cmos_sensor(0x03, 0x11);
+	HI704_write_cmos_sensor(0x10, 0x25);  
+
+	HI704_write_cmos_sensor(0x03, 0x20);
+
+	HI704_write_cmos_sensor(0x83, HI704_pv_exposure_lines >> 16);
+	HI704_write_cmos_sensor(0x84, (HI704_pv_exposure_lines >> 8) & 0x000000FF);
+	HI704_write_cmos_sensor(0x85, HI704_pv_exposure_lines & 0x000000FF);
+
+	
+//	HI704_Set_Mirror_Flip(sensor_config_data->SensorImageMirror);//wmhai  add it
+	SENSORDB("[HI704][Enter]HI704_capture_func sensor_config_data->SensorImageMirror %d\n",sensor_config_data->SensorImageMirror);
+	//HI704_Write_Shutter(HI704_pv_exposure_lines);
+	mdelay(100);
 	return ERROR_NONE;
 }	/* HM3451Capture() */
 
@@ -977,7 +1201,7 @@
 	pSensorInfo->SensorWebCamCaptureFrameRate=15;
 	pSensorInfo->SensorResetActiveHigh=FALSE;//low is to reset 
 	pSensorInfo->SensorResetDelayCount=4;  //4ms 
-	pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_YUYV; //SENSOR_OUTPUT_FORMAT_YVYU;
+	pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_YUYV;
 	pSensorInfo->SensorClockPolarity=SENSOR_CLOCK_POLARITY_LOW;	
 	pSensorInfo->SensorClockFallingPolarity=SENSOR_CLOCK_POLARITY_LOW;
 	pSensorInfo->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
@@ -1010,8 +1234,8 @@
 	pSensorInfo->SensorISOBinningInfo.ISOBinningInfo[ISO_1600_MODE].ISOSupported=TRUE;
 	pSensorInfo->SensorISOBinningInfo.ISOBinningInfo[ISO_1600_MODE].BinningEnable=TRUE;
 
-	pSensorInfo->CaptureDelayFrame = 4; 
-	pSensorInfo->PreviewDelayFrame = 4;//10; 
+	pSensorInfo->CaptureDelayFrame =8; 
+	pSensorInfo->PreviewDelayFrame = 10; 
 	pSensorInfo->VideoDelayFrame = 0; 
 	pSensorInfo->SensorMasterClockSwitch = 0; 
        pSensorInfo->SensorDrivingCurrent = ISP_DRIVING_8MA;   		
@@ -1028,16 +1252,15 @@
 			pSensorInfo->SensorDataLatchCount= 2;
 	        pSensorInfo->SensorGrabStartX = 1; 
 	        pSensorInfo->SensorGrabStartY = 10;  			
-			
 		break;
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_MEM:
 			pSensorInfo->SensorClockFreq=26;
-			pSensorInfo->SensorClockDividCount=	3;
+			pSensorInfo->SensorClockDividCount=	1;
 			pSensorInfo->SensorClockRisingCount= 0;
-			pSensorInfo->SensorClockFallingCount= 2;
-			pSensorInfo->SensorPixelClockCount= 3;
-			pSensorInfo->SensorDataLatchCount= 2;
+			pSensorInfo->SensorClockFallingCount= 1;
+			pSensorInfo->SensorPixelClockCount= 1;
+			pSensorInfo->SensorDataLatchCount= 1;
             pSensorInfo->SensorGrabStartX = 1; 
             pSensorInfo->SensorGrabStartY = 10;//1;     			
 		break;
@@ -1052,7 +1275,7 @@
             pSensorInfo->SensorGrabStartY = 10;//1;     			
 		break;
 	}
-//	HI704_PixelClockDivider=pSensorInfo->SensorPixelClockCount;
+	//	HI704_PixelClockDivider=pSensorInfo->SensorPixelClockCount;
 	memcpy(pSensorConfigData, &HI704SensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
 
 	SENSORDB("[Exit]:HI704 getInfo func\n");
@@ -1076,20 +1299,36 @@
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_MEM:
 			 HI704Capture(pImageWindow, pSensorConfigData); 
+			 //HI704_Set_Mirror_Flip(IMAGE_V_MIRROR);//mingji add 0208
+			 //HI704_Set_Mirror_Flip(IMAGE_H_MIRROR);
 			 break;
 		default:
 		     break; 
 	}
 
    SENSORDB("[Exit]:HI704 Control func\n");
-	
 	return TRUE;
 }	/* HI704Control() */
 
 
+/*************************************************************************
+* FUNCTION
+*	HI704_set_param_wb
+*
+* DESCRIPTION
+*	wb setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 BOOL HI704_set_param_wb(UINT16 para)
 {
-	
     //This sensor need more time to balance AWB, 
     //we suggest higher fps or drop some frame to avoid garbage color when preview initial
    SENSORDB("[Enter]HI704 set_param_wb func:para = %d\n",para);
@@ -1103,19 +1342,20 @@
 		case AWB_MODE_AUTO:
 			{
 		        HI704_write_cmos_sensor(0x03, 0x22);			
-		        HI704_write_cmos_sensor(0x11, 0x2e);				
-		        HI704_write_cmos_sensor(0x80, 0x38);
-	            HI704_write_cmos_sensor(0x82, 0x38);				
-		        HI704_write_cmos_sensor(0x83, 0x5e);
-		        HI704_write_cmos_sensor(0x84, 0x24);
-	            HI704_write_cmos_sensor(0x85, 0x59);
-		        HI704_write_cmos_sensor(0x86, 0x24);				
+			HI704_write_cmos_sensor(0x10,0x6a);                                                                                                                 
+			HI704_write_cmos_sensor(0x83,0x52);                                 
+			HI704_write_cmos_sensor(0x84, 0x1b);
+			HI704_write_cmos_sensor(0x85, 0x50);
+			HI704_write_cmos_sensor(0x86,0x25);                     
+			HI704_write_cmos_sensor(0x03,0x22);                                                          
+			HI704_write_cmos_sensor(0x10,0xea);  			
             }                
 		    break;
+		
 		case AWB_MODE_CLOUDY_DAYLIGHT:
 			{
 		        HI704_write_cmos_sensor(0x03, 0x22);
-	            HI704_write_cmos_sensor(0x11, 0x28);
+			HI704_write_cmos_sensor(0x10,0x6a);                                                          
 		        HI704_write_cmos_sensor(0x80, 0x71);
 		        HI704_write_cmos_sensor(0x82, 0x2b);
 		        HI704_write_cmos_sensor(0x83, 0x72);
@@ -1124,10 +1364,11 @@
 	            HI704_write_cmos_sensor(0x86, 0x28);
 	        }			   
 		    break;
+		
 		case AWB_MODE_DAYLIGHT:
 		    {
 	            HI704_write_cmos_sensor(0x03, 0x22);
-	            HI704_write_cmos_sensor(0x11, 0x28);          
+			HI704_write_cmos_sensor(0x10,0x6a);                                                          
 	            HI704_write_cmos_sensor(0x80, 0x59);
 	            HI704_write_cmos_sensor(0x82, 0x29);
 	            HI704_write_cmos_sensor(0x83, 0x60);
@@ -1136,10 +1377,11 @@
 	            HI704_write_cmos_sensor(0x86, 0x23);
             }      
 		    break;
+		
 		case AWB_MODE_INCANDESCENT:	
 		    {
 		        HI704_write_cmos_sensor(0x03, 0x22);
-		        HI704_write_cmos_sensor(0x11, 0x28);          
+			HI704_write_cmos_sensor(0x10,0x6a);                                                          
 		        HI704_write_cmos_sensor(0x80, 0x29);
 		        HI704_write_cmos_sensor(0x82, 0x54);
 		        HI704_write_cmos_sensor(0x83, 0x2e);
@@ -1148,10 +1390,11 @@
 		        HI704_write_cmos_sensor(0x86, 0x4f);
             }		
 		    break;  
+		
 		case AWB_MODE_FLUORESCENT:
 		    {
 	            HI704_write_cmos_sensor(0x03, 0x22);
-	            HI704_write_cmos_sensor(0x11, 0x28);
+			HI704_write_cmos_sensor(0x10,0x6a);                                                          
 	            HI704_write_cmos_sensor(0x80, 0x41);
 	            HI704_write_cmos_sensor(0x82, 0x42);
 	            HI704_write_cmos_sensor(0x83, 0x44);
@@ -1160,11 +1403,12 @@
 	            HI704_write_cmos_sensor(0x86, 0x3a);
             }	
 		    break;  
+		
 		case AWB_MODE_TUNGSTEN:
 		   {
 	            HI704_write_cmos_sensor(0x03, 0x22);
+			HI704_write_cmos_sensor(0x10,0x6a);                                                          
 	            HI704_write_cmos_sensor(0x80, 0x24);
-	            HI704_write_cmos_sensor(0x81, 0x20);
 	            HI704_write_cmos_sensor(0x82, 0x58);
 	            HI704_write_cmos_sensor(0x83, 0x27);
 	            HI704_write_cmos_sensor(0x84, 0x22);
@@ -1176,14 +1420,27 @@
 		default:
 			return FALSE;
 	}
-
 	return TRUE;
-	
 } /* HI704_set_param_wb */
 
+/*************************************************************************
+* FUNCTION
+*	HI704_set_param_effect
+*
+* DESCRIPTION
+*	effect setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 BOOL HI704_set_param_effect(UINT16 para)
 {
-
    SENSORDB("[Enter]HI704 set_param_effect func:para = %d\n",para);
    
    if(HI704_sensor.effect == para) return KAL_TRUE;
@@ -1266,15 +1523,28 @@
 		default:
 			return KAL_FALSE;
 	}
-
 	return KAL_TRUE;
-
 } /* HI704_set_param_effect */
 
+/*************************************************************************
+* FUNCTION
+*	HI704_set_param_banding
+*
+* DESCRIPTION
+*	banding setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 BOOL HI704_set_param_banding(UINT16 para)
 {
 
-
 	SENSORDB("[Enter]HI704 set_param_banding func:para = %d\n",para);
 
 	
@@ -1287,32 +1557,53 @@
 		case AE_FLICKER_MODE_50HZ:
 		    {
 				HI704_write_cmos_sensor(0x03,0x20);
+		    HI704_write_cmos_sensor(0x10,0x1c);
+			HI704_write_cmos_sensor(0x18,0x38);
+			HI704_write_cmos_sensor(0x83,0x00);
+			HI704_write_cmos_sensor(0x84,0xbe);
+			HI704_write_cmos_sensor(0x85,0x6e);
 				HI704_write_cmos_sensor(0x10,0x9c);
+			HI704_write_cmos_sensor(0x18,0x30);
 		    }
 			break;
 
 		case AE_FLICKER_MODE_60HZ:
 		    {
 				HI704_write_cmos_sensor(0x03,0x20);
+			HI704_write_cmos_sensor(0x10,0x0c);
+			HI704_write_cmos_sensor(0x18,0x38);
+			HI704_write_cmos_sensor(0x83,0x00);
+			HI704_write_cmos_sensor(0x84,0xd2);
+			HI704_write_cmos_sensor(0x85,0xf0);
 				HI704_write_cmos_sensor(0x10,0x8c);
+			HI704_write_cmos_sensor(0x18,0x30);
 		    }
 			break;
 
 	     default:
 	          return KAL_FALSE;
 	}
-
-
 	return KAL_TRUE;
 } /* HI704_set_param_banding */
 
-
-
-
+/*************************************************************************
+* FUNCTION
+*	HI704_set_param_exposure
+*
+* DESCRIPTION
+*	exposure setting.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
 BOOL HI704_set_param_exposure(UINT16 para)
 {
-
-
 	SENSORDB("[Enter]HI704 set_param_exposure func:para = %d\n",para);
 
 	
@@ -1337,7 +1628,7 @@
 			HI704_write_cmos_sensor(0x40,0x18);	
 			break;    
 		case AE_EV_COMP_00:  // +0 EV
-		    HI704_write_cmos_sensor(0x40,0x10);
+		    HI704_write_cmos_sensor(0x40,0x88);
 			break;    
 		case AE_EV_COMP_n03:  // -1 EV
 			HI704_write_cmos_sensor(0x40,0x98);
@@ -1354,19 +1645,17 @@
 		default:
 			return FALSE;
 	}
-
 	return TRUE;
-	
 } /* HI704_set_param_exposure */
 
 
 UINT32 HI704YUVSensorSetting(FEATURE_ID iCmd, UINT32 iPara)
 {
+
     SENSORDB("[Enter]HI704YUVSensorSetting func:cmd = %d\n",iCmd);
 	
 	switch (iCmd) {
 	case FID_SCENE_MODE:	    //auto mode or night mode
-
 		    if (iPara == SCENE_MODE_OFF)//auto mode
 		    {
 		        HI704_night_mode(FALSE); 
@@ -1375,7 +1664,6 @@
 		    {
 	            HI704_night_mode(TRUE); 
 		    }	
-			
 	     break; 	    
 	case FID_AWB_MODE:
            HI704_set_param_wb(iPara);
@@ -1400,55 +1688,32 @@
 
 UINT32 HI704YUVSetVideoMode(UINT16 u2FrameRate)
 {
+
    HI704_sensor.MPEG4_Video_mode = KAL_TRUE;
     SENSORDB("[Enter]HI704 Set Video Mode:FrameRate= %d\n",u2FrameRate);
 	SENSORDB("HI704_sensor.video_mode = %d\n",HI704_sensor.MPEG4_Video_mode);
 
-    if(u2FrameRate == 30) u2FrameRate = 20;
+	//    if(u2FrameRate == 30) u2FrameRate = 25;
    
 	
-	HI704_sensor.fix_framerate = u2FrameRate * 10;
+	//HI704_sensor.fix_framerate = u2FrameRate * 10;
     
     if(HI704_sensor.fix_framerate <= 300 )
     {
-      HI704_Fix_Video_Frame_Rate(HI704_sensor.fix_framerate); 
+	  //HI704_Fix_Video_Frame_Rate(HI704_sensor.fix_framerate); 
     }
     else 
     {
-        SENSORDB("Wrong Frame Rate"); 
+	   // SENSORDB("Wrong Frame Rate"); 
     }
-    
-    
+	HI704_VIDEO_ENABLE = KAL_TRUE;
     return TRUE;
 }
 
-void HI704GetAFMaxNumFocusAreas(UINT32 *pFeatureReturnPara32)
-{	
-    *pFeatureReturnPara32 = 0;    
-    SENSORDB("HI704GetAFMaxNumFocusAreas *pFeatureReturnPara32 = %d\n",  *pFeatureReturnPara32);
-}
-
-void HI704GetAEMaxNumMeteringAreas(UINT32 *pFeatureReturnPara32)
-{     
-    *pFeatureReturnPara32 = 0;    
-    SENSORDB("HI704GetAEMaxNumMeteringAreas *pFeatureReturnPara32 = %d\n",  *pFeatureReturnPara32);	
-}
-
-void HI704GetExifInfo(UINT32 exifAddr)
-{
-    SENSOR_EXIF_INFO_STRUCT* pExifInfo = (SENSOR_EXIF_INFO_STRUCT*)exifAddr;
-    pExifInfo->FNumber = 28;
-    pExifInfo->AEISOSpeed = AE_ISO_100;
-    pExifInfo->AWBMode = HI704_sensor.wb;
-    pExifInfo->CapExposureTime = 0;
-    pExifInfo->FlashLightTimeus = 0;
-    pExifInfo->RealISOValue = AE_ISO_100;
-
-}
-
 UINT32 HI704FeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId,
 							 UINT8 *pFeaturePara,UINT32 *pFeatureParaLen)
 {
+
     UINT16 u2Temp = 0; 
 	UINT16 *pFeatureReturnPara16=(UINT16 *) pFeaturePara;
 	UINT16 *pFeatureData16=(UINT16 *) pFeaturePara;
@@ -1527,19 +1792,6 @@
 		case SENSOR_FEATURE_CHECK_SENSOR_ID:
 			HI704_GetSensorID(pFeatureData32); 
 			break; 
-    case SENSOR_FEATURE_GET_AF_MAX_NUM_FOCUS_AREAS:
-        HI704GetAFMaxNumFocusAreas(pFeatureReturnPara32);            
-        *pFeatureParaLen=4;
-        break;        
-    case SENSOR_FEATURE_GET_AE_MAX_NUM_METERING_AREAS:
-        HI704GetAEMaxNumMeteringAreas(pFeatureReturnPara32);            
-        *pFeatureParaLen=4;
-        break;   
-    case SENSOR_FEATURE_GET_EXIF_INFO:
-        SENSORDB("SENSOR_FEATURE_GET_EXIF_INFO\n");
-        SENSORDB("EXIF addr = 0x%x\n",*pFeatureData32);          
-        HI704GetExifInfo(*pFeatureData32);
-        break;        
 		default:
 			 break;			
 	}
@@ -1566,4 +1818,3 @@
 	return ERROR_NONE;
 }	/* SensorInit() */
 
-
diff -rubN hi704_yuv/hi704yuv_Sensor.h hi704_yuv.iq255/hi704yuv_Sensor.h
--- hi704_yuv/hi704yuv_Sensor.h	2012-11-13 05:55:59.000000000 +0200
+++ hi704_yuv.iq255/hi704yuv_Sensor.h	2012-05-02 21:05:52.000000000 +0300
@@ -1,4 +1,109 @@
-
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   PC Huang (MTK02204)
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * 07 11 2011 jun.pei
+ * [ALPS00059464] hi704 sensor check in
+ * .
+ * 
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
 /* SENSOR FULL SIZE */
 #ifndef __SENSOR_H
 #define __SENSOR_H
@@ -30,7 +135,6 @@
 #define HI704_MIN_FRAMERATE_5					(50)
 #define HI704_MIN_FRAMERATE_7_5 				(75)
 #define HI704_MIN_FRAMERATE_10					(100)
-#define HI704_MIN_FRAMERATE_15                  (150)
 
 //Video Fixed Framerate
 #define HI704_VIDEO_FIX_FRAMERATE_5 			(50)
